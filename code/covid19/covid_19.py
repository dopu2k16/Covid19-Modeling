# -*- coding: utf-8 -*-
"""Covid-19.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1k0as5r66yZX8aWAJj31w7hMzv5pvnE7m

## Data Analysis and Prediction of confirmed cases for COVID-19 using Machine Learning

In December 2019, a novel coronavirus was found in a seafood wholesale market in Wuhan, China. World Health Organization (WHO) officially named this coronavirus as COVID-19. Since the first patient was hospitalized on
December 12, 2019, China has reported a total of 78,824 confirmed COVID-19 cases and 2,788 deaths as of February 28, 2020. The COVID-19 has been successfully contained in China but is spreading all over the world. COVID-19
epidemic is prone to disrupt and crumble the existing health-care infrastructures in both the developed and developing world. COVID19 also impacts people’s daily life and country’s economic development. In this notebook, we adopt mathematical epidemic models such as Susceptible-Infected-Recovery (SIR) to simulate the epidemic on the data available for the entire world and future projections on the number of infections, deaths in six specific countries (Italy, France, Spain, Germany, USA, and India). In the latter section, we also used statistical machine
learning techniques such as Polynomial regression, support vector machine regression, and simple neural network such as multilayer perceptron to better understand and learns the underlying pattern of the real epidemic growth and the virus proliferation pattern. We found out that the predictions by
the logistic model was underreported, i.e, the actual trajectory is more complex than the logistic model. However, we found out that different models found to be better in modeling the pandemic outbreak in respective countries. We also performed data analysis to project the infection, recovery, and death
statistics from the real data and also calculated the growth factor of pandemic outbreak in the countries and grouping them respectively. To our future projections and analysis, we found out USA, followed by India are gonna be the most affected countries with each resulting into millions of positive infections
cases and deaths.

# Download required libraries
* Sklearn
* Tensorflow
* Keras
* Matplotlib
* Pandas
* Numpy
* Folium
* Pycountry_Convert
* XGBoost
* LightGBM
* Scipy
"""

!pip install pycountry_convert 
!pip install folium

#Mounting google drive
from google.colab import drive
drive.mount('/content/gdrive', force_remount=True)

"""# Importing libraries"""

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/gdrive/My Drive/Covid19

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from matplotlib import ticker 
import pycountry_convert as pc
import folium
from datetime import datetime, timedelta,date
from scipy.interpolate import make_interp_spline, BSpline
import plotly.express as px
import json, requests

from keras.layers import Input, Dense, Activation, LeakyReLU
from keras import models
from keras.optimizers import RMSprop, Adam
import numpy as np 
import pandas as pd 
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn import preprocessing
import time
from datetime import datetime
import warnings
warnings.filterwarnings('ignore')

# ML libraries
import lightgbm as lgb
import xgboost as xgb
from xgboost import plot_importance, plot_tree
from sklearn.model_selection import RandomizedSearchCV, GridSearchCV
from sklearn import linear_model
from sklearn.metrics import mean_squared_error
from sklearn.neural_network import MLPRegressor
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, LSTM

from tensorflow.keras.preprocessing.sequence import TimeseriesGenerator

# %matplotlib inline

"""# COVID-19 Data Analysis"""

# Retriving Dataset
df_confirm_cases = pd.read_csv('https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv')
df_deaths = pd.read_csv('https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_deaths_global.csv')

# Depricated
# df_recovered = pd.read_csv('https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_19-covid-Recovered.csv')
df_covid19_world = pd.read_csv("https://raw.githubusercontent.com/CSSEGISandData/COVID-19/web-data/data/cases_country.csv")

df_covid19_world['Country_Region']

df_confirm_cases[df_confirm_cases['Country/Region'] == 'Italy'].columns

df_deaths

def plot_params(ax,axis_label= None, plt_title = None,label_size=15, axis_fsize = 15, title_fsize = 20, scale = 'linear' ):
    # Tick-Parameters
    ax.xaxis.set_minor_locator(ticker.AutoMinorLocator())
    ax.yaxis.set_minor_locator(ticker.AutoMinorLocator())
    ax.tick_params(which='both', width=1,labelsize=label_size)
    ax.tick_params(which='major', length=6)
    ax.tick_params(which='minor', length=3, color='0.8')

    # Grid
    plt.grid(lw = 1, ls = '-', c = "0.7", which = 'major')
    plt.grid(lw = 1, ls = '-', c = "0.9", which = 'minor')

    # Plot Title
    plt.title( plt_title,{'fontsize':title_fsize})
    
    # Yaxis sacle
    plt.yscale(scale)
    
    # Plot Axes Labels
    xl = plt.xlabel(axis_label[0],fontsize = axis_fsize)
    yl = plt.ylabel(axis_label[1],fontsize = axis_fsize)
    
def visualize_covid_cases(confirmed, deaths, continent=None , country = None , state = None, period = None, figure = None, scale = "linear"):
    x = 0
    if figure == None:
        f = plt.figure(figsize=(10,10))
        # Sub plot
        ax = f.add_subplot(111)
    else :
        f = figure[0]
        # Sub plot
        ax = f.add_subplot(figure[1],figure[2],figure[3])
    
    #plt.tight_layout(pad=10, w_pad=5, h_pad=5)
    plt.tight_layout()
    
    stats = [confirmed, deaths]
    label = ["Confirmed", "Deaths"]
    
    if continent != None:
        params = ["continent",continent]
    elif country != None:
        params = ["Country/Region",country]
    else: 
        params = ["All", "All"]

    for i,stat in enumerate(stats):
        if params[1] == "All" :
            cases = np.sum(np.asarray(stat.iloc[:,5:]),axis = 0)[x:]
        else :
            cases = np.sum(np.asarray(stat[stat[params[0]] == params[1]].iloc[:,5:]),axis = 0)[x:]
        date = np.arange(1,cases.shape[0]+1)[x:]
        plt.plot(date,cases,label = label[i]+" (Total : "+str(cases[-1])+")")

    if params[1] == "All" :
        Total_confirmed = np.sum(np.asarray(stats[0].iloc[:,5:]),axis = 0)[x:]
        Total_deaths = np.sum(np.asarray(stats[1].iloc[:,5:]),axis = 0)[x:]
    else :
        Total_confirmed =  np.sum(np.asarray(stats[0][stat[params[0]] == params[1]].iloc[:,5:]),axis = 0)[x:]
        Total_deaths = np.sum(np.asarray(stats[1][stat[params[0]] == params[1]].iloc[:,5:]),axis = 0)[x:]
        
    text = "From "+stats[0].columns[5]+" to "+stats[0].columns[-1]+"\n"
    text += "Mortality rate : "+ str(int(Total_deaths[-1]/(Total_confirmed[-1])*10000)/100)+"\n"
    text += "Last 5 Days:\n"
    text += "Confirmed : " + str(Total_confirmed[-1] - Total_confirmed[-6])+"\n"
    text += "Deaths : " + str(Total_deaths[-1] - Total_deaths[-6])+"\n"
    text += "Last 24 Hours:\n"
    text += "Confirmed : " + str(Total_confirmed[-1] - Total_confirmed[-2])+"\n"
    text += "Deaths : " + str(Total_deaths[-1] - Total_deaths[-2])+"\n"
    
    plt.text(0.02, 0.78, text, fontsize=15, horizontalalignment='left', verticalalignment='top', transform=ax.transAxes,bbox=dict(facecolor='white', alpha=0.4))
    
    # Plot Axes Labels
    axis_label = ["Days ("+df_confirm_cases.columns[5]+" - "+df_confirm_cases.columns[-1]+")","No of Cases"]
    
    # Plot Parameters
    plot_params(ax,axis_label,scale = scale)
    
    # Plot Title
    if params[1] == "All" :
        plt.title("COVID-19 Cases World",{'fontsize':25})
    else:   
        plt.title("COVID-19 Cases for "+params[0]+" "+params[1] ,{'fontsize':25})
        
    # Legend Location
    l = plt.legend(loc= "best",fontsize = 15)
    
    if figure == None:
        plt.show()
        
def get_total_cases(cases, country = "All"):
    if(country == "All") :
        return np.sum(np.asarray(cases.iloc[:,5:]),axis = 0)[-1]
    else :
        return np.sum(np.asarray(cases[cases["country"] == country].iloc[:,5:]),axis = 0)[-1]
    
def get_mortality_rate(confirmed,deaths, continent = None, country = None):
    if continent != None:
        params = ["continent",continent]
    elif country != None:
        params = ["country",country]
    else :
        params = ["All", "All"]
    
    if params[1] == "All" :
        Total_confirmed = np.sum(np.asarray(confirmed.iloc[:,5:]),axis = 0)
        Total_deaths = np.sum(np.asarray(deaths.iloc[:,5:]),axis = 0)
        mortality_rate = np.round((Total_deaths/Total_confirmed)*100,2)
    else :
        Total_confirmed =  np.sum(np.asarray(confirmed[confirmed[params[0]] == params[1]].iloc[:,5:]),axis = 0)
        Total_deaths = np.sum(np.asarray(deaths[deaths[params[0]] == params[1]].iloc[:,5:]),axis = 0)
        mortality_rate = np.round((Total_deaths/Total_confirmed)*100,2)
    
    return np.nan_to_num(mortality_rate)
def dd(date1,date2):
    return (datetime.strptime(date1,'%m/%d/%y') - datetime.strptime(date2,'%m/%d/%y')).days

df_countries_cases = df_covid19_world.copy().drop(['Lat','Long_','Last_Update'],axis =1)
df_countries_cases.index = df_countries_cases["Country_Region"]
df_countries_cases = df_countries_cases.drop(['Country_Region'],axis=1)

#df_continents_cases = df_covid19.copy().drop(['Lat','Long_','country','Last_Update'],axis =1)
#df_continents_cases = df_continents_cases.groupby(["continent"]).sum()

df_countries_cases.index
for i, country in enumerate(df_countries_cases.index):
    print(country)

df_countries_cases.drop(['People_Tested','People_Hospitalized'], axis=1).sort_values('Confirmed', ascending= False).style.background_gradient(cmap='Wistia')

img = plt.figure(figsize=(10,5))
img.add_subplot(111)

plt.barh(df_countries_cases.sort_values('Confirmed')["Confirmed"].index[-10:],df_countries_cases.sort_values('Confirmed')["Confirmed"].values[-10:],)
plt.tick_params(size=5,labelsize = 13)
plt.xlabel("Confirmed Cases",fontsize=18)
plt.title("Top 10 Countries (Confirmed Cases)",fontsize=20)
plt.grid(alpha=0.3)
plt.savefig('Top 10 Countries (Confirmed Cases).png')

img = plt.figure(figsize=(10,5))
img.add_subplot(111)

plt.barh(df_countries_cases.sort_values('Deaths')["Deaths"].index[-10:],df_countries_cases.sort_values('Deaths')["Deaths"].values[-10:])
plt.tick_params(size=5,labelsize = 13)
plt.xlabel("Confirmed Cases",fontsize=18)
plt.title("Top 10 Countries (Deaths Cases)",fontsize=20)
plt.grid(alpha=0.3)
plt.savefig('Top 10 Countries (Deaths Cases).png')

df_countries_cases.corr().style.background_gradient(cmap='Reds')

temp = df_confirm_cases.groupby('Country/Region').sum().drop(["Lat","Long"],axis =1).sort_values(df_confirm_cases.columns[-1], ascending= False)

t=temp.loc[temp.index=='Germany'].values[0]

len(temp.columns)

temp.columns

temp = df_confirm_cases.groupby('Country/Region').sum().drop(["Lat","Long"],axis =1).sort_values(df_confirm_cases.columns[-1], ascending= False)

threshold = 50
f = plt.figure(figsize=(20,25))
ax = f.add_subplot(111)
for i,country in enumerate(temp.index):
    if i >= 10:
        if country != "India":
            continue
    x = 122
    t = temp.loc[temp.index== country].values[0]
    #t = t[t>=threshold][:x]
    t=t[:x]
     
    date = np.arange(0,len(t[:x]))
    xnew = np.linspace(date.min(), date.max(), 10)
    spl = make_interp_spline(date, t, k=1)  # type: BSpline
    power_smooth = spl(xnew)
    if country != "India":
        plt.plot(xnew,power_smooth,label = country,linewidth =2)
    else:
        marker_style = dict(linewidth=4, linestyle='-', marker='o',markersize=10, markerfacecolor='#ffffff')
        plt.plot(date,t,"-.",label = country,**marker_style)

plt.tick_params(labelsize = 14)        
plt.xticks(np.arange(0,122,7),[ "Day "+str(i) for i in range(122)][::7])     
'''
# Reference lines 
x = np.arange(0,64)
y = 2**(x+np.log2(threshold))
plt.plot(x,y,"--",linewidth =2,color = "red")
plt.annotate("doubles every day",(x[-2],y[-1]),color ="Red", xycoords="data",fontsize=14,alpha = 0.5)

x = np.arange(0,64)
y = 2**(x/2+np.log2(threshold))
plt.plot(x,y,"--",linewidth =2,color = "black")
plt.annotate("doubles every second day",(x[-3],y[-1]), color="Red", xycoords="data",fontsize=14,alpha = 0.5)

x = np.arange(0,64)
y = 2**(x/7+np.log2(threshold))
plt.plot(x,y,"--",linewidth =2,color = "cyan")
plt.annotate("doubles every week",(x[-3],y[-1]),color="Red", xycoords="data",fontsize=14,alpha = 0.5)

x = np.arange(0,64)
y = 2**(x/30+np.log2(threshold))
plt.plot(x,y,"--",linewidth =2,color = "gray")
plt.annotate("doubles every month",(x[-3],y[-1]), color="Red", xycoords="data",fontsize=14,alpha = 0.5)


# India is following trend similar to doulbe the cases in 4 days but it may increase the rate 
x = np.arange(0,64)
y = 2**(x/4+np.log2(threshold))
plt.plot(x,y,"--",linewidth =2,color = "blue")
plt.annotate("doubles every 4 days",(x[-3],y[-1]),color="Red",xycoords="data",fontsize=14,alpha = 0.8)
'''
# plot Params
plt.xlabel("Days",fontsize=17)
plt.ylabel("Number of Confirmed Cases",fontsize=17)
plt.title("Variation of confirmed cases across countries v/s time",fontsize=22)
plt.legend(loc = "upper left")
plt.yscale("log")
plt.grid(which="both")
plt.savefig('Trend_comp_may.png')
plt.show()

temp = df_deaths.groupby('Country/Region').sum().drop(["Lat","Long"],axis =1).sort_values(df_confirm_cases.columns[-1], ascending= False)

threshold = 10
f = plt.figure(figsize=(20,25))
ax = f.add_subplot(111)
for i,country in enumerate(temp.index):
    if i >= 10:
        if country != "India":
            continue
        
    x = 105
    t = temp.loc[temp.index== country].values[0]
    #t = t[t>threshold][:x]
    t=t[:x]
     
    date = np.arange(0,len(t[:x]))
    xnew = np.linspace(date.min(), date.max(), 10)
    spl = make_interp_spline(date, t, k=1)  # type: BSpline
    power_smooth = spl(xnew)
    if country != "India":
        plt.plot(xnew,power_smooth,label = country,linewidth =2)
    else:
        marker_style = dict(linewidth=4, linestyle='-', marker='o',markersize=10, markerfacecolor='#ffffff')
        plt.plot(date,t,"-.",label = country,**marker_style)


plt.tick_params(labelsize = 14)        
plt.xticks(np.arange(0,105,7),[ "Day "+str(i) for i in range(105)][::7])     
'''
# Reference lines 
x = np.arange(0,18)
y = 2**(x+np.log2(threshold))
plt.plot(x,y,"--",linewidth =2,color = "red")
plt.annotate("doubles every day",(x[-2],y[-1]),color="Red", xycoords="data",fontsize=14,alpha = 0.5)

x = np.arange(0,26)
y = 2**(x/2+np.log2(threshold))
plt.plot(x,y,"--",linewidth =2,color = "black")
plt.annotate("doubles every second day",(x[-3],y[-1]),color="Red", xycoords="data",fontsize=14,alpha = 0.5)

x = np.arange(0,26)
y = 2**(x/7+np.log2(threshold))
plt.plot(x,y,"--",linewidth =2,color = "cyan")
plt.annotate("doubles every week",(x[-3],y[-1]), color="Red", xycoords="data",fontsize=14,alpha = 0.5)

x = np.arange(0,26)
y = 2**(x/30+np.log2(threshold))
plt.plot(x,y,"--",linewidth =2,color = "gray")
plt.annotate("doubles every month",(x[-3],y[-1]), color="Red", xycoords="data",fontsize=14,alpha = 0.5)

# India is following trend similar to doulbe the cases in 4 days but it may increase the rate 
x = np.arange(0,26)
y = 2**(x/4+np.log2(threshold))
plt.plot(x,y,"--",linewidth =2,color = "blue")
plt.annotate("doubles every 4 days",(x[-3],y[-1]), color="Red",xycoords="data",fontsize=14,alpha = 0.8)
'''

# plot Params
plt.xlabel("Days",fontsize=17)
plt.ylabel("Number of Deaths",fontsize=17)
plt.title("Number of deaths v/s time across different countries (Author:Mitodru)",fontsize=22)
plt.legend(loc = "upper left")
plt.yscale("log")
plt.grid(which="both")
plt.savefig('Trend Comparision with India.png')
plt.show()

world_map = folium.Map(location=[10,0], tiles="cartodbpositron", zoom_start=2,max_zoom=6,min_zoom=2)
for i in range(0,len(df_confirm_cases)):
    folium.Circle(
        location=[df_confirm_cases.iloc[i]['Lat'], df_confirm_cases.iloc[i]['Long']],
        tooltip = "<h5 style='text-align:center;font-weight: bold'>"+df_confirm_cases.iloc[i]['Country/Region']+"</h5>"+
                    "<div style='text-align:center;'>"+str(np.nan_to_num(df_confirm_cases.iloc[i]['Province/State']))+"</div>"+
                    "<hr style='margin:10px;'>"+
                    "<ul style='color: #444;list-style-type:circle;align-item:left;padding-left:20px;padding-right:20px'>"+
        "<li>Confirmed: "+str(df_confirm_cases.iloc[i,-1])+"</li>"+
        "<li>Deaths:   "+str(df_deaths.iloc[i,-1])+"</li>"+
        "<li>Mortality Rate:   "+str(np.round(df_deaths.iloc[i,-1]/(df_confirm_cases.iloc[i,-1]+1.00001)*100,2))+"</li>"+
        "</ul>"
        ,
        radius=(int((np.log(df_confirm_cases.iloc[i,-1]+1.00001)))+0.2)*50000,
        color='#ff6600',
        fill_color='#ff8533',
        fill=True).add_to(world_map)

world_map

world_map.save('visualization_mortality_conf.html')

df_countries_cases

case_nums_country = df_confirm_cases.groupby("Country/Region").sum().drop(['Lat','Long'],axis =1).apply(lambda x: x[x > 0].count(), axis =0)
d = [datetime.strptime(date,'%m/%d/%y').strftime("%d %b") for date in case_nums_country.index]

f = plt.figure(figsize=(15,8))
f.add_subplot(111)

marker_style = dict(linewidth=6, linestyle='-', marker='o',markersize=8, markerfacecolor='#ffffff')
plt.plot(d, case_nums_country,**marker_style)
plt.tick_params(labelsize = 14)
plt.xticks(list(np.arange(0,len(d),int(len(d)/5))),d[:-1:int(len(d)/5)]+[d[-1]])

#labels
plt.xlabel("Dates",fontsize=18)
plt.ylabel("Number of Countries/Regions",fontsize=18)
plt.grid(alpha = 0.3)
plt.savefig('spread.png')

case_nums_country

cols = 1
rows = 1
f = plt.figure(figsize=(15,12))
visualize_covid_cases(df_confirm_cases, df_deaths,continent = "All",figure = [f,rows,cols, 1])

plt.savefig('COIVD-19-World.png')

plt.show()

df_countries = df_confirm_cases.groupby(["Country/Region"]).sum()
df_countries = df_countries.sort_values(df_countries.columns[-1],ascending = False)
countries = df_countries[df_countries[df_countries.columns[-1]] >= 100000].index

cols =2
rows = int(np.ceil(countries.shape[0]/cols))
f = plt.figure(figsize=(20,8*rows))
for i,country in enumerate(countries):
    visualize_covid_cases(df_confirm_cases, df_deaths, country = country,figure = [f,rows,cols, i+1])
plt.savefig('Most affected countires.png')
plt.show()

df_countries[df_countries.columns[-1]]

df_countries[df_countries[df_countries.columns[-1]] >= 700]

df_countries[df_countries[df_countries.columns[-1]] >= 700].index

pop_italy = 60486683
df_countries_cases[df_countries_cases.index== 'Italy']

(pop_italy-df_countries_cases[df_countries_cases.index== 'Italy']['Confirmed']-df_countries_cases[df_countries_cases.index== 'Italy']['Recovered']-df_countries_cases[df_countries_cases.index== 'Italy']['Deaths'])/pop_italy

R1=0
type(R1)

df_countries_cases.Confirmed

"""# SIR modelling"""

from scipy.integrate import odeint
from scipy import integrate, optimize
import matplotlib.pyplot as plt

pop_italy = 60486683
pop_spain = 46749696
pop_UK = 67784927
pop_singapore = 5837230
N = pop_italy
I0 = df_countries_cases[df_countries_cases.index== 'Italy']['Confirmed']
#R0 = 0
R0= df_countries_cases[df_countries_cases.index== 'Italy']['Recovered'] + df_countries_cases[df_countries_cases.index =='Italy']['Deaths']
print(R0)
R0=R0.item()
#sus0 = N - inf0
#rec0 = 0.0
# Total population, N.
#N = 1000
# Initial number of infected and recovered individuals, I0 and R0.
#I0, R0 = 1, 0
# Everyone else, S0, is susceptible to infection initially.
S0 = N - I0 - R0
# Contact rate, beta, and mean recovery rate, gamma, (in 1/days).
beta, gamma = 0.2, 1./10 
# A grid of time points (in days)
t = np.linspace(0, 180, 180)

# The SIR model differential equations.
def deriv(y, t, N, beta, gamma):
    S, I, R = y
    dSdt = -beta * S * I / N
    dIdt = beta * S * I / N - gamma * I
    dRdt = gamma * I
    return dSdt, dIdt, dRdt

# Initial conditions vector
y0 = S0, I0, R0
# Integrate the SIR equations over the time grid, t.
ret = odeint(deriv, y0, t, args=(N, beta, gamma))
S, I, R = ret.T
# Plot the data on three separate curves for S(t), I(t) and R(t)
fig = plt.figure(facecolor='w', figsize= (10,14))
ax = fig.add_subplot(111, axisbelow=True)
ax.plot(t, S/pop_italy, 'b', alpha=0.5, lw=2, label='Susceptible')
ax.plot(t, I/pop_italy, 'r', alpha=0.5, lw=2, label='Infected')
ax.plot(t, R/pop_italy, 'g', alpha=0.5, lw=2, label='Recovered with immunity')
ax.set_xlabel('Time /days')
ax.set_ylabel('Number (1000s)')
ax.set_ylim(0,1.2)
ax.yaxis.set_tick_params(length=0)
ax.xaxis.set_tick_params(length=0)
ax.grid(b=True, which='major', c='w', lw=2, ls='-')
legend = ax.legend()
legend.get_frame().set_alpha(0.5)
for spine in ('top', 'right', 'bottom', 'left'):
    ax.spines[spine].set_visible(False)
plt.title("SIR model for Italy considering initial recovery+deaths=23809, beta =0.2, gamma = 0.1")
plt.savefig('initial SIR model for Italy.png')

df_confirm_cases['1/22/20']

from scipy.integrate import odeint
from scipy import integrate, optimize
import matplotlib.pyplot as plt

#country_df = total_date_Italy[9:]
#country_df['day_count'] = list(range(1,len(country_df)+1))

ydata = [df_italy[col].item() for i, col in enumerate(df_italy.columns[4:])]
xdata = [i for i in range(len(ydata))]
ydata = np.array(ydata, dtype=float)
xdata = np.array(xdata, dtype=float)


pop_italy = float(60486683)
pop_spain = 46749696
pop_UK = 67784927
pop_singapore = 5837230
N = pop_italy
inf0 = 555.0
#inf0=df_confirm_cases['1/22/20']
#inf0 = ydata[0]
sus0 = N - inf0
rec0 = 0
y0 = sus0, inf0, rec0
def sir_model(y, x, beta, gamma):
    sus = -beta * y[0] * y[1] / N
    rec = gamma * y[1]
    inf = -(sus + rec)
    return sus, inf, rec

def fit_odeint(x, beta, gamma):

    return integrate.odeint(sir_model, (sus0, inf0, rec0), x, args=(beta, gamma))[:,1]
#ret = odeint(deriv, y0, t, args=(N, beta, gamma))[:,-1]
popt, pcov = optimize.curve_fit(fit_odeint, xdata, ydata)
fitted = fit_odeint(xdata, *popt)

plt.plot(xdata, ydata, 'o')
plt.plot(xdata, fitted)
plt.title("Fit of SIR model to global infected cases")
plt.ylabel("Population infected")
plt.xlabel("Days")
plt.show()
print("Optimal parameters: beta =", popt[0], " and gamma = ", popt[1])

"""# Machine Learning Models for Prediction of confirmed cases in future
* Polynomial Regression
* SVM Regression
* Random Forest Regression
* Multilayer Perceptron Neural Network
"""

pop_italy = 60486683.
pop_spain = 46749696.
pop_UK = 67784927.
pop_singapore = 5837230

from sklearn.linear_model import LinearRegression, BayesianRidge
from sklearn.model_selection import RandomizedSearchCV, train_test_split
from sklearn.preprocessing import PolynomialFeatures
from sklearn.tree import DecisionTreeRegressor
from sklearn.svm import SVR
from sklearn.metrics import mean_squared_error, mean_absolute_error

confirmed_df = pd.read_csv('https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv')
deaths_df = pd.read_csv('https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_deaths_global.csv')
df_recoveries = pd.read_csv('https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_recovered_global.csv')

deaths_df

df_recoveries.keys()
cols = df_confirm_cases.keys()

confirmed = df_confirm_cases.loc[:, cols[4]:cols[-1]]
deaths = df_deaths.loc[:, cols[4]:cols[-1]]
recoveries =df_recoveries.loc[:, cols[4]:cols[-1]]
confirmed

len(confirmed.keys())

# Aggregating cases for individual countries respectively
dates = confirmed.keys()
#dates = dates[:60]
world_cases = []
total_deaths = [] 
mortality_rate = []
recovery_rate = [] 
total_recovered = [] 
total_active = [] 
china_cases = [] 
italy_cases = []
us_cases = [] 
spain_cases = []
germany_cases = []
india_cases =[]
south_korea_cases = [] 
uk_cases = []
france_cases = []

for i in dates:
    confirmed_sum = confirmed[i].sum()
    death_sum = deaths[i].sum()
    recovered_sum = recoveries[i].sum()
    
    # confirmed, deaths, recovered, and active
    world_cases.append(confirmed_sum)
    total_deaths.append(death_sum)
    total_recovered.append(recovered_sum)
    total_active.append(confirmed_sum-death_sum-recovered_sum)
    
    # calculate rates
    mortality_rate.append(death_sum/confirmed_sum)
    recovery_rate.append(recovered_sum/confirmed_sum)

    # case studies 
    china_cases.append(df_confirm_cases[df_confirm_cases['Country/Region']=='China'][i].sum())
    italy_cases.append(df_confirm_cases[df_confirm_cases['Country/Region']=='Italy'][i].sum())
    us_cases.append(df_confirm_cases[df_confirm_cases['Country/Region']=='US'][i].sum())
    spain_cases.append(df_confirm_cases[df_confirm_cases['Country/Region']=='Spain'][i].sum())
    germany_cases.append(df_confirm_cases[df_confirm_cases['Country/Region'] == 'Germany'][i].sum())
    india_cases.append(df_confirm_cases[df_confirm_cases['Country/Region'] == 'India'][i].sum())
    south_korea_cases.append(df_confirm_cases[df_confirm_cases['Country/Region'] == 'South Korea'][i].sum())
    uk_cases.append(df_confirm_cases[df_confirm_cases['Country/Region'] == 'United Kingdom'][i].sum())
    france_cases.append(df_confirm_cases[df_confirm_cases['Country/Region'] == 'France'][i].sum())

# Future forcasting
days_in_future = 30
days_till_train =60
future_forcast = np.array([i for i in range(days_till_train + days_in_future)]).reshape(-1, 1)
train_dates = future_forcast[:-days_in_future]

len(train_dates)

# Functions to calculate daily increase cases for countries
def daily_increase(data):
    d = [] 
    for i in range(len(data)):
        if i == 0:
            d.append(data[0])
        else:
            d.append(data[i]-data[i-1])
    return d 

world_daily_increase = daily_increase(world_cases)
china_daily_increase = daily_increase(china_cases)
italy_daily_increase = daily_increase(italy_cases)
us_daily_increase = daily_increase(us_cases)
spain_daily_increase = daily_increase(spain_cases)
germany_daily_increase = daily_increase(germany_cases)
india_daily_increase = daily_increase(india_cases)
south_korea_daily_increase = daily_increase(south_korea_cases)
uk_daily_increase = daily_increase(uk_cases)
france_daily_increase = daily_increase(france_cases)

days_since_1_22 = np.array([i for i in range(len(dates))]).reshape(-1, 1)
world_cases = np.array(world_cases).reshape(-1, 1)
total_deaths = np.array(total_deaths).reshape(-1, 1)
total_recovered = np.array(total_recovered).reshape(-1, 1)

len(days_since_1_22)
#len(dates)

import datetime
start = '1/22/2020'
start_date = datetime.datetime.strptime(start, '%m/%d/%Y')
future_forcast_dates = []
for i in range(len(future_forcast)):
    future_forcast_dates.append((start_date + datetime.timedelta(days=i)).strftime('%m/%d/%Y'))

len(future_forcast)
from sklearn.preprocessing import PolynomialFeatures
from sklearn.linear_model import HuberRegressor
from sklearn.pipeline import make_pipeline

# Multilayer Perceptron prediction
def MLP_predict(trainx, trainy, future_forecast, country_cases):
    model = MLPRegressor(hidden_layer_sizes=[len(trainx), int(len(trainx)/2), int(len(trainx)/2), 30], max_iter=20000, random_state=42)
    MLP = model.fit(trainx, trainy)
    pred_MLP = model.predict(future_forecast)
    print('MSE:',mean_squared_error(country_cases[:len(future_forcast)], pred_MLP))
    return pred_MLP

# SVM Regression prediction
def SVM_poly(trainx, trainy, future_forecast, country_cases):
    svm_model = SVR(shrinking=True, kernel='poly',gamma=0.01, epsilon=1, degree=8, C=0.1)
    svm_model.fit(trainx, trainy)
    svm_pred = svm_model.predict(future_forecast)
    print('MSE:',mean_squared_error(country_cases[:len(future_forecast)], svm_pred))
    return svm_pred

# Grid Search for hyperparamters tuning
from sklearn.model_selection import GridSearchCV
from sklearn.svm import SVR
def SVM_pred_country(trainx, trainy, future_forecast,country_cases):
    kernel = ['poly', 'rbf']
    c = [0.01, 0.1, 1, 10, 100]
    gamma = [ 0.001, 0.01, 0.1, 10]
    epsilon = [0.01, 0.1, 1, 10, 100]
    shrinking = [True, False]
    svm_grid = {'kernel': kernel, 'C': c, 'gamma' : gamma, 'epsilon': epsilon, 'shrinking' : shrinking}
    svm = SVR()
    svm_search = GridSearchCV(svm, svm_grid, scoring='neg_mean_squared_error', cv=5, return_train_score=True, n_jobs=-1,verbose=1)
    svm_search.fit(trainx, trainy)
    print(svm_search.best_params_)
    print(svm_search.best_params_)
    svm_pred = svm_search.best_estimator_.predict(future_forecast)
    print('MSE:',mean_squared_error(country_cases[:len(future_forcast)], pred_svm))
    return svm_pred

# Random forest regression for prediction
from sklearn.ensemble import RandomForestRegressor as regr
def poly_regression_regr(X_train_confirmed, country_cases, future_forcast):
    linear_model = regr(n_jobs=-1)
    estimators=100
    scores=[]
    linear_model.set_params(n_estimators=estimators)
    linear_model.fit(X_train_confirmed, country_cases)
    #scores.append(linear_model.score(X_test, y_test))
    #linear_model = LinearRegression(normalize=True, fit_intercept=False)
    #linear_model.fit(X_train_confirmed, y_train_confirmed)
    poly_pred_future_forcast = linear_model.predict(future_forcast)
    #poly_pred_future_forcast = np.exp(poly_pred_future_forcast)
    #print('MAE:', mean_absolute_error(y_valid_confirmed, valid_linear_pred))
    #print('MSE:',mean_squared_error(y_valid_confirmed, valid_linear_pred))
    return poly_pred_future_forcast

from sklearn.ensemble import RandomForestRegressor as regr
from lightgbm import LGBMRegressor
def poly_regression_lgbmr(X_train_confirmed, y_train_confirmed, future_forcast):
    linear_model = LGBMRegressor(n_estimators=1300)
    linear_model.fit(X_train_confirmed, y_train_confirmed)
    #linear_model = LinearRegression(normalize=True, fit_intercept=False)
    #linear_model.fit(X_train_confirmed, y_train_confirmed)
    #valid_linear_pred = linear_model.predict(X_valid_confirmed)
    poly_pred_future_forcast = linear_model.predict(future_forcast)
    #poly_pred_future_forcast = np.exp(poly_pred_future_forcast)
    #print('MAE:', mean_absolute_error(y_valid_confirmed, valid_linear_pred))
    #print('MSE:',mean_squared_error(y_valid_confirmed, valid_linear_pred))
    return poly_pred_future_forcast

# Polynomial Regression for prediction
from sklearn.preprocessing import PolynomialFeatures
from sklearn.linear_model import HuberRegressor
from sklearn.pipeline import make_pipeline
def poly_regression_2(X_train_confirmed, y_train_confirmed, future_forcast, country_cases):
    poly = PolynomialFeatures(degree=8)
    poly_X_train_confirmed = poly.fit_transform(X_train_confirmed)
    #poly_X_valid_confirmed = poly.fit_transform(X_valid_confirmed)
    poly_future_forcast = poly.fit_transform(future_forcast)
    linear_model = make_pipeline(PolynomialFeatures(2), HuberRegressor())
    #linear_model = LinearRegression(normalize=True, fit_intercept=False)
    linear_model.fit(X_train_confirmed, y_train_confirmed)
    #valid_linear_pred = linear_model.predict(X_valid_confirmed)
    poly_pred_future_forcast = linear_model.predict(future_forcast)
    print('MSE:',mean_squared_error(country_cases[:len(future_forcast)], poly_pred_future_forcast))
    #print('MAE:', mean_absolute_error(y_valid_confirmed, valid_linear_pred))
    #print('MSE:',mean_squared_error(y_valid_confirmed, valid_linear_pred))
    return poly_pred_future_forcast

len(days_since_1_22)

# Plotting the ML models predictions togther for individual countries
def plot_prediction(country_cases, train_dates, future_forcast, mlp_pred_country, svm_pred_country, poly_reg_pred_country, country_name):
    plt.figure(figsize=(12, 9))
    plt.plot(train_dates, country_cases[:days_till_train], color = 'black', marker ='o')
    plt.plot(future_forcast, mlp_pred_country, color = 'blue')
    plt.plot(future_forcast, svm_pred_country, color ='green')
    plt.plot(future_forcast, poly_reg_pred_country, color='purple')
    plt.plot(days_since_1_22[:len(future_forcast)], country_cases[:len(future_forcast)], color = 'yellow')
    plt.title(f'# of Coronavirus Cases in {country_name} Over Time', size=30)
    plt.xlabel('Days Since 1/22/2020', size=30)
    plt.ylabel('# of Cases', size=30)
    plt.legend(['Confirmed Cases(Train) till 03/22/2020', 'MLP Prediction', 'SVM Prediction', 'Polynomial Regression Prediction', 'Confirmed cases'], prop={'size': 20})
    plt.xticks(size=20)
    plt.yticks(size=20)
    plt.savefig(f'ml_pred_{country_name}.png')
    plt.show()

random_forest_pred = poly_regression_regr(days_since_1_22, germany_cases, future_forcast)

random_forest_pred

poly_reg_pred = poly_regression(days_since_1_22, germany_cases, future_forcast)

poly_reg_pred

mlp_pred_country = MLP_predict(train_dates, world_cases[:days_till_train], future_forcast, world_cases)

mlp_pred_country

poly_pred_country = poly_regression_2(train_dates, world_cases[:days_till_train], future_forcast, world_cases)

poly_pred_country

pred_svm_country = SVM_poly(train_dates, world_cases[:days_till_train], future_forcast, world_cases)

poly_lgbm_pred =poly_regression_lgbmr(days_since_1_22,germany_cases, future_forcast)

poly_lgbm_pred

len(germany_cases)

future_forcast_dates[len(train_dates)]

plot_prediction(world_cases, train_dates, future_forcast, mlp_pred_country, pred_svm_country, poly_pred_country, country_name = 'World')
